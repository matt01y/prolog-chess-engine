:- module(non_directional, [
    king_moves/4,
    knight_moves/4,
    pawn_moves/4
    ]).

:- use_module('../board/board_utils').
:- use_module('../utils').
:- use_module('../move_gen/pawn').
:- use_module('../move_gen/check_check').

% king_moves(+Board, +Coord, +Color, -King_moves)
% get all the moves for the king at the given coordinates.
king_moves(Board, Coord, Piece, Moves):-
    all_moves_from(Board, Coord, Piece, King_moves, king_options),
    castling_moves(Board, Coord, Piece, Castling_moves),
    two_dl_to_one_dl(King_moves, Castling_moves, Moves).

castling_moves(Board, R/5, p(Color, king), Castling_moves):-
    castle_row(Color, R),
    meta(king_moved, Color, false),
    short_castle(Board, Color, ShortCastle),
    long_castle(Board, Color, LongCastle),
    two_dl_to_one_dl(ShortCastle, LongCastle, Castling_moves).

short_castle(Board, Color, Move):-
    (meta(short_rook_moved, Color, false),
    castle_row(Color, R),
    get_piece_at(R/6, Board, p(empty)),
    get_piece_at(R/7, Board, p(empty)),
    move_piece(Board, m(king, R/5, R/6, none), TestBoard),
    not(in_check(TestBoard, Color))) ->
    Move = [m(castle, short)|X]-X;
    Move = X-X.

long_castle(Board, Color, Move):-
    (meta(long_rook_moved, Color, false),
    castle_row(Color, R),
    get_piece_at(R/4, Board, p(empty)),
    get_piece_at(R/3, Board, p(empty)),
    get_piece_at(R/2, Board, p(empty)),
    move_piece(Board, m(king, R/5, R/4, none), TestBoard),
    not(in_check(TestBoard, Color))) ->
    Move = [m(castle, long)|X]-X;
    Move = X-X.

% king_options(_, _, move(+Coord, -NewCoord))
% get a plausible move for the given king at the given coordinates.
king_options(_, _, move(R/C, NR/NC), king):-
    member(DeltaX, [-1, 0, 1]),
    member(DeltaY, [-1, 0, 1]),
    NR is R + DeltaX,
    NC is C + DeltaY.

% knight_moves(+Board, +Coord, +Color, -Knight_moves)
% get all the moves for the knight at the given coordinates.
knight_moves(Board, Coord, Piece, Knight_moves):-
    all_moves_from(Board, Coord, Piece, Knight_moves, knight_options).

% knight_options(_, _, move(+Coord, -NewCoord))
% get a plausible move for the given knight at the given coordinates.
knight_options(_, _, move(R/C, NR/NC), knight):-
    member(DeltaX, [-2, -1, 1, 2]),
    member(DeltaY, [-2, -1, 1, 2]),
    abs(DeltaX, AbsDeltaX),
    abs(DeltaY, AbsDeltaY),
    % this check makes sure a knight move is always in the L shape
    AbsDeltaX + AbsDeltaY =:= 3,
    NR is R + DeltaX,
    NC is C + DeltaY.

% pawn_moves(+Board, +Coord, +Color, -Pawn_moves)
% get all the moves for the given pawn at the given coordinates.
pawn_moves(Board, Coord, Piece, Pawn_moves):-
    all_moves_from(Board, Coord, Piece, Pawn_moves, pawn_move_wrapper).

% all_moves_from(+Board, +Coord, +Color, -Moves, +Func)
% get all the moves for the piece at the given coordinates, that is generated by Func.
all_moves_from(Board, Coord, p(Color, _), Moves, Func):-
    findall(
        Move,
        ( 
            call(Func, Board, Color, move(Coord, NewCoord), MoveType),
            % stop if move is illegal
            not(is_illegal_coord(NewCoord)),
            % can't move to a square with a piece of the same color
            not(get_piece_at(NewCoord, Board, p(Color, _))),
            attacking_state(MoveType, NewCoord, Board, Color, AttackingState),
            % Move needs to be a difference list so that we can merge em into 1
            Move = [m(MoveType, Coord, NewCoord, AttackingState)| X]-X 
        ),
        K_Moves
    ),
    flatten_DLs_to_one_DL(K_Moves, Moves).

% attacking_state(+MoveType, +NewCoord, +Board, +Color, -AttackingState)
% get the attacking state of the move.
attacking_state(en_passent, _, _, _, attacking).
attacking_state(_, NewCoord, Board, Color, attacking):-
    other_color(Color, OppositeColor),
    get_piece_at(NewCoord, Board, p(OppositeColor, _)).
attacking_state(Type, NewCoord, Board, Color, none):-
    Type \= attacking,
    other_color(Color, OppositeColor),
    not(get_piece_at(NewCoord, Board, p(OppositeColor, _))).